<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dashboard</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.2/color-thief.umd.js"></script>

    <style>
      /* ========== DESIGN SYSTEM ========== */
      :root {
        /* Palette principale */
        --bg-primary: #0a0e14;
        --bg-secondary: #13171e;
        --bg-card: rgba(25, 30, 40, 0.6);
        --bg-card-hover: rgba(30, 36, 48, 0.8);

        /* Couleurs d'accent dynamiques */
        --accent-primary: #4ecdc4;
        --accent-secondary: #a78bfa;
        --accent-warm: #ff6b9d;
        --accent-gradient: linear-gradient(
          135deg,
          var(--accent-primary),
          var(--accent-secondary)
        );

        /* Texte */
        --text-primary: #f8fafc;
        --text-secondary: #94a3b8;
        --text-muted: #64748b;

        /* Effets */
        --blur-sm: blur(8px);
        --blur-md: blur(16px);
        --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.15);
        --shadow-md: 0 4px 20px rgba(0, 0, 0, 0.25);
        --shadow-lg: 0 8px 40px rgba(0, 0, 0, 0.4);
        --shadow-glow: 0 0 30px rgba(78, 205, 196, 0.15);

        /* Spacing & Layout */
        --gap-sm: 0.75rem;
        --gap-md: 1.25rem;
        --gap-lg: 2rem;
        --radius-sm: 1rem;
        --radius-md: 1.5rem;
        --radius-lg: 2rem;

        /* Animations */
        --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
        --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
        --duration-fast: 0.2s;
        --duration-normal: 0.4s;
        --duration-slow: 0.8s;
      }

      /* ========== BASE STYLES ========== */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: var(--bg-primary);
        color: var(--text-primary);
        font-family: "Inter", -apple-system, system-ui, sans-serif;
        overflow: hidden;
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      /* Ambient background particles */
      body::before {
        content: "";
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(
            circle at 20% 30%,
            rgba(78, 205, 196, 0.08) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 70%,
            rgba(167, 139, 250, 0.06) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 50% 50%,
            rgba(255, 107, 157, 0.04) 0%,
            transparent 50%
          );
        animation: ambient 20s ease-in-out infinite alternate;
        pointer-events: none;
      }

      @keyframes ambient {
        0% {
          transform: translate(0, 0) rotate(0deg);
        }
        100% {
          transform: translate(5%, 3%) rotate(5deg);
        }
      }

      /* ========== LAYOUT GRID ========== */
      .dashboard {
        display: grid;
        grid-template-columns: repeat(12, 1fr);
        grid-template-rows: repeat(10, 1fr);
        gap: var(--gap-md);
        padding: var(--gap-md);
        width: 100%;
        height: 100%;
        position: relative;
        z-index: 1;
      }

      /* ========== CARD BASE ========== */
      .card {
        background: var(--bg-card);
        backdrop-filter: var(--blur-md);
        -webkit-backdrop-filter: var(--blur-md);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: var(--radius-lg);
        padding: var(--gap-lg);
        box-shadow: var(--shadow-md);
        overflow: hidden;
        position: relative;
        transition: all var(--duration-normal) var(--ease-smooth);
        display: flex;
        flex-direction: column;
        min-height: 0; /* allow flex children to shrink inside grid cells */
        opacity: 0;
        transform: scale(0.95) translateY(10px);
      }

      .card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--accent-gradient);
        opacity: 0;
        transition: opacity var(--duration-normal);
        pointer-events: none;
        z-index: -1;
      }

      .card:not(.hidden) {
        animation: cardEnter var(--duration-slow) var(--ease-smooth) forwards;
      }

      .card.hidden {
        animation: cardExit var(--duration-normal) var(--ease-smooth) forwards;
        pointer-events: none;
      }

      /* Subtle breathing animation */
      @keyframes breathe {
        0%,
        100% {
          box-shadow: var(--shadow-md);
          transform: scale(1);
        }
        50% {
          box-shadow: var(--shadow-md), var(--shadow-glow);
          transform: scale(1.005);
        }
      }

      .card:not(.hidden):not(#musicCard) {
        animation: cardEnter var(--duration-slow) var(--ease-smooth) forwards,
          breathe 8s ease-in-out 1s infinite;
      }

      @keyframes cardEnter {
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      @keyframes cardExit {
        to {
          opacity: 0;
          transform: scale(0.9) translateY(-10px);
        }
      }

      /* ========== TIME CARD ========== */
      #timeCard {
        grid-column: 1 / 5;
        grid-row: 1 / 5;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: calc(var(--gap-md) * 1.25);
      }

      .time-display {
        font-size: clamp(2rem, 6vw, 4rem);
        font-weight: 700;
        letter-spacing: -0.03em;
        background: var(--accent-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-shadow: 0 0 40px rgba(78, 205, 196, 0.3);
        animation: timeGlow 4s ease-in-out infinite;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        white-space: nowrap;
        padding: 0 var(--gap-sm);
      }

      @keyframes timeGlow {
        0%,
        100% {
          filter: brightness(1);
        }
        50% {
          filter: brightness(1.2);
        }
      }

      /* ========== WEATHER CARD ========== */
      #weatherCard {
        grid-column: 1 / 5;
        grid-row: 5 / 11;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: calc(var(--gap-md) * 1.25);
      }

      .weather-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: var(--gap-lg);
        width: 100%;
        height: 100%;
      }

      .weather-icon {
        width: clamp(120px, 18vw, 180px);
        height: clamp(120px, 18vw, 180px);
        filter: drop-shadow(0 8px 20px rgba(78, 205, 196, 0.4));
        animation: weatherFloat 6s ease-in-out infinite;
      }

      @keyframes weatherFloat {
        0%,
        100% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-10px);
        }
      }

      .weather-text {
        text-align: center;
        font-size: clamp(1.1rem, 2.5vw, 1.5rem);
        font-weight: 500;
        color: var(--text-secondary);
        line-height: 1.4;
      }

      .weather-temp {
        font-size: clamp(3rem, 6vw, 5rem);
        font-weight: 700;
        color: var(--text-primary);
        margin-top: 0.25rem;
        text-shadow: 0 2px 12px rgba(78, 205, 196, 0.3);
        width: 100%;
        display: flex;
        justify-content: center;
      }

      /* ========== FORECAST CARD (HERO) ========== */
      #forecastCard {
        grid-column: 5 / 13;
        grid-row: 1 / 5;
        display: flex;
        flex-direction: column;
        background: var(--bg-card-hover);
        border: 1px solid rgba(78, 205, 196, 0.15);
        transition: grid-row var(--duration-normal) var(--ease-smooth);
      }

      #forecastCard.expanded {
        grid-row: 1 / 11;
      }

      #forecastCard::before {
        opacity: 0.03;
      }

      .forecast-header {
        font-size: 0.875rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: var(--text-muted);
        margin-bottom: var(--gap-md);
      }

      .forecast-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: var(--gap-sm);
        flex: 1;
        align-items: stretch;
        height: 100%;
      }

      #forecastCard.expanded .forecast-grid {
        gap: var(--gap-md);
      }

      .forecast-item {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.05);
        border-radius: var(--radius-md);
        padding: var(--gap-md);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--gap-sm);
        transition: all var(--duration-fast) var(--ease-smooth);
        height: 100%;
        justify-content: center;
      }

      .forecast-item:hover {
        background: rgba(255, 255, 255, 0.05);
        transform: translateY(-2px);
      }

      .forecast-time {
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--text-muted);
        letter-spacing: 0.05em;
      }

      .forecast-icon {
        width: 48px;
        height: 48px;
        filter: drop-shadow(0 2px 8px rgba(78, 205, 196, 0.2));
        transition: all var(--duration-normal) var(--ease-smooth);
      }

      #forecastCard.expanded .forecast-icon {
        width: 72px;
        height: 72px;
      }

      .forecast-temp {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--text-primary);
        transition: font-size var(--duration-normal) var(--ease-smooth);
      }

      #forecastCard.expanded .forecast-temp {
        font-size: 2rem;
      }

      .forecast-desc {
        font-size: 0.7rem;
        color: var(--text-secondary);
        text-align: center;
        line-height: 1.3;
      }

      /* ========== MUSIC CARD ========== */
      #musicCard {
        grid-column: 5 / 13;
        grid-row: 5 / 11;
        flex-direction: column;
        align-items: stretch;
        justify-content: flex-start;
        gap: calc(var(--gap-lg) * 1.5);
        padding: calc(var(--gap-lg) * 1.5);
        background: rgba(255, 107, 157, 0.15);
        border: 1px solid rgba(255, 107, 157, 0.3);
      }

      #musicCard:not(.hidden) {
        animation: cardEnter var(--duration-slow) var(--ease-smooth) forwards;
      }

      #musicCard::before {
        opacity: 0.1;
      }

      .music-cover-wrapper {
        position: relative;
        flex-shrink: 0;
      }

      .music-cover {
        width: clamp(80px, 8vw, 100px);
        height: clamp(80px, 8vw, 100px);
        border-radius: var(--radius-md);
        object-fit: cover;
        box-shadow: var(--shadow-lg), 0 0 40px rgba(255, 107, 157, 0.3);
        animation: coverPulse 3s ease-in-out infinite;
      }

      @keyframes coverPulse {
        0%,
        100% {
          transform: scale(1);
          box-shadow: var(--shadow-lg);
        }
        50% {
          transform: scale(1.02);
          box-shadow: var(--shadow-lg), 0 0 30px rgba(255, 107, 157, 0.4);
        }
      }

      .music-info {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 0.5rem;
        min-width: 0;
      }

      .music-track {
        font-size: clamp(1.125rem, 1.75vw, 1.5rem);
        font-weight: 700;
        color: var(--text-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        line-height: 1.2;
      }

      .music-artist {
        font-size: clamp(0.875rem, 1.25vw, 1rem);
        font-weight: 500;
        color: var(--text-secondary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        opacity: 0.9;
      }

      .music-progress {
        width: 100%;
        height: 4px;
        background: rgba(255, 255, 255, 0.12);
        border-radius: 4px;
        overflow: hidden;
        margin-top: 0.5rem;
      }

      .music-progress-bar {
        height: 100%;
        background: var(--accent-gradient);
        border-radius: 2px;
        width: 0%;
        transition: width 200ms linear;
        box-shadow: 0 0 18px rgba(78, 205, 196, 0.28);
      }

      .music-progress-row {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        width: 100%;
      }

      .music-duration {
        color: var(--text-secondary);
        font-size: 0.8rem;
        min-width: 42px;
        text-align: right;
        opacity: 0.95;
      }

      /* Music bottom section */
      .music-bottom {
        display: flex;
        flex-direction: row;
        gap: var(--gap-md);
        align-items: center;
        flex-shrink: 0;
      }

      /* ========== RESPONSIVE ADJUSTMENTS ========== */
      @media (max-width: 1200px) {
        .forecast-grid {
          grid-template-columns: repeat(3, 1fr);
        }

        .forecast-item:nth-child(n + 4) {
          display: none;
        }
      }

      @media (max-height: 800px) {
        .dashboard {
          gap: var(--gap-sm);
          padding: var(--gap-md);
        }

        .card {
          padding: var(--gap-md);
        }
      }

      /* ========== LYRICS ========== */
      .lyrics-container {
        position: relative;
        flex: 1;
        min-width: 0;
        width: 100%;
        min-height: 0;
        overflow: hidden;
        mask-image: linear-gradient(
          to bottom,
          transparent 0%,
          rgba(0, 0, 0, 0.4) 15%,
          rgba(0, 0, 0, 1) 40%,
          rgba(0, 0, 0, 1) 60%,
          rgba(0, 0, 0, 0.4) 85%,
          transparent 100%
        );
        -webkit-mask-image: linear-gradient(
          to bottom,
          transparent 0%,
          rgba(0, 0, 0, 0.4) 15%,
          rgba(0, 0, 0, 1) 40%,
          rgba(0, 0, 0, 1) 60%,
          rgba(0, 0, 0, 0.4) 85%,
          transparent 100%
        );
      }

      .lyrics-wrapper {
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: transform 0.6s cubic-bezier(0.25, 0.1, 0.25, 1);
      }

      .lyrics-loading,
      .lyrics-none {
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        color: var(--text-muted);
        font-size: 0.95rem;
        font-weight: 500;
        text-align: center;
        padding: 2rem;
      }

      .lyrics-loading.active,
      .lyrics-none.active {
        display: flex;
      }

      .lyrics-loading-spinner {
        width: 24px;
        height: 24px;
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-top-color: var(--accent-primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .lyrics-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.75rem;
        padding: 4rem 1rem;
        width: 100%;
      }

      .lyrics-line {
        font-size: 1.75rem;
        font-weight: 500;
        color: var(--text-muted);
        text-align: center;
        line-height: 1.5;
        padding: 0.5rem 0.5rem;
        border-radius: 0.5rem;
        transition: all 0.4s cubic-bezier(0.25, 0.1, 0.25, 1);
        opacity: 0.4;
        transform: scale(0.95);
        filter: blur(0.5px);
        cursor: default;
        max-width: 100%;
        word-wrap: break-word;
        overflow-wrap: break-word;
        hyphens: auto;
      }

      .lyrics-line.active {
        font-weight: 600;
        color: var(--text-primary);
        opacity: 1;
        transform: scale(1.08);
        filter: blur(0);
        text-shadow: 0 0 20px rgba(78, 205, 196, 0.4);
      }

      .lyrics-line.past {
        opacity: 0.5;
        filter: blur(0);
      }

      .lyrics-line.near {
        opacity: 0.7;
        filter: blur(0);
        transform: scale(0.98);
      }

      /* Responsive lyrics */
      @media (max-width: 1400px) {
        .lyrics-line {
          font-size: 1.6rem;
        }
      }

      @media (max-width: 1100px) {
        .lyrics-line {
          font-size: 1.5rem;
        }
      }

      /* ========== UTILITY ========== */
      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div class="dashboard">
      <!-- TIME CARD -->
      <div id="timeCard" class="card hidden">
        <div class="time-display" id="time">00:00:00</div>
      </div>

      <!-- WEATHER CARD -->
      <div id="weatherCard" class="card hidden">
        <div class="weather-content">
          <img id="weatherIcon" src="" alt="weather" class="weather-icon" />
          <div>
            <div class="weather-text" id="weather">Chargement...</div>
            <div class="weather-temp" id="weatherTemp"></div>
          </div>
        </div>
      </div>

      <!-- FORECAST CARD (HERO) -->
      <div id="forecastCard" class="card hidden">
        <div class="forecast-header">Prévisions</div>
        <div class="forecast-grid" id="forecast"></div>
      </div>

      <!-- MUSIC CARD -->
      <div id="musicCard" class="card hidden">
        <!-- LYRICS CONTAINER -->
        <div class="lyrics-container" id="lyricsContainer">
          <div class="lyrics-wrapper" id="lyricsWrapper">
            <div class="lyrics-loading" id="lyricsLoading">
              <div class="lyrics-loading-spinner"></div>
              <span>Chargement des paroles...</span>
            </div>
            <div class="lyrics-none" id="lyricsNone">
              Pas de paroles disponibles
            </div>
            <div class="lyrics-content" id="lyricsContent"></div>
          </div>
        </div>

        <!-- MUSIC INFO BOTTOM -->
        <div class="music-bottom">
          <div class="music-cover-wrapper">
            <img id="cover" src="" alt="Cover" class="music-cover" />
          </div>
          <div class="music-info">
            <div class="music-track" id="track">Titre</div>
            <div class="music-artist" id="artist">Artiste</div>
            <div class="music-progress-row">
              <div class="music-progress">
                <div class="music-progress-bar" id="progressBar"></div>
              </div>
              <div class="music-duration" id="musicDuration">0:00</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const socket = io();

      // ========== CONFIGURATION ==========
      const config = {
        showTime: true,
        showWeather: true,
        showForecast: true,
        showSeconds: true,
        // Delay (in seconds) to apply to lyrics timing. Useful to compensate
        // network/request latency or clock offsets. Can be changed at runtime
        // via `setLyricsDelay(seconds)` or provided per-track via socket.
        lyricsDelaySeconds: +1,
      };

      // ========== DOM ELEMENTS ==========
      const timeEl = document.getElementById("time");
      const weatherEl = document.getElementById("weather");
      const weatherTempEl = document.getElementById("weatherTemp");
      const weatherIconEl = document.getElementById("weatherIcon");
      const timeCard = document.getElementById("timeCard");
      const weatherCard = document.getElementById("weatherCard");
      const musicCard = document.getElementById("musicCard");
      const forecastCard = document.getElementById("forecastCard");
      const forecastEl = document.getElementById("forecast");
      const trackEl = document.getElementById("track");
      const artistEl = document.getElementById("artist");
      const coverEl = document.getElementById("cover");
      const progressBar = document.getElementById("progressBar");
      const musicDurationEl = document.getElementById("musicDuration");

      // ========== INITIALIZATION ==========
      function init() {
        updateDisplay();
        if (config.showWeather) getWeather();
        if (config.showForecast) getForecast();
        startClock();
      }

      function updateDisplay() {
        // Délai progressif pour animation en cascade
        const cards = [
          { el: timeCard, show: config.showTime, delay: 0 },
          { el: weatherCard, show: config.showWeather, delay: 100 },
          { el: forecastCard, show: config.showForecast, delay: 200 },
        ];

        cards.forEach(({ el, show, delay }) => {
          setTimeout(() => {
            el.classList.toggle("hidden", !show);
          }, delay);
        });

        // Expand forecast when music is hidden
        updateForecastLayout();
      }

      function updateForecastLayout() {
        const musicHidden = musicCard.classList.contains("hidden");
        forecastCard.classList.toggle("expanded", musicHidden);
      }

      // ========== CLOCK ==========
      function startClock() {
        function updateClock() {
          if (!config.showTime) return;
          const now = new Date();
          const opts = { hour: "2-digit", minute: "2-digit" };
          if (config.showSeconds) opts.second = "2-digit";
          timeEl.textContent = now.toLocaleTimeString([], opts);
        }
        updateClock();
        setInterval(updateClock, 1000);
      }

      // ========== WEATHER ==========
      function getWeather() {
        if (!config.showWeather) return;
        fetch("/api/weather")
          .then((res) => res.json())
          .then((data) => {
            weatherEl.textContent = `${data.name} · ${data.desc}`;
            weatherTempEl.textContent = `${data.temp}°C`;
            weatherIconEl.src = `/weather-icons/${data.icon}.svg`;
          })
          .catch(() => {
            weatherEl.textContent = "Erreur météo";
          });
      }

      // Refresh weather every 30min
      setInterval(() => {
        if (config.showWeather) getWeather();
      }, 30 * 60000);

      // ========== FORECAST ==========
      function getForecast() {
        if (!config.showForecast) return;

        fetch("/api/forecast")
          .then((res) => res.json())
          .then((data) => {
            forecastEl.innerHTML = "";
            data.list.forEach((f, index) => {
              const time = new Date(f.dt * 1000).toLocaleTimeString([], {
                hour: "2-digit",
                minute: "2-digit",
              });

              const item = document.createElement("div");
              item.className = "forecast-item";
              item.style.animationDelay = `${index * 50}ms`;
              item.innerHTML = `
                <div class="forecast-time">${time}</div>
                <img class="forecast-icon" src="/weather-icons/${
                  f.icon
                }.svg" alt="${f.description}" />
                <div class="forecast-temp">${Math.round(f.temp)}°C</div>
                <div class="forecast-desc">${f.description}</div>
              `;
              forecastEl.appendChild(item);
            });
          })
          .catch((err) => {
            console.error("Forecast error:", err);
          });
      }

      // Refresh forecast every hour
      setInterval(() => {
        if (config.showForecast) getForecast();
      }, 60 * 60000);

      // ========== LYRICS ==========
      const lyricsContainer = document.getElementById("lyricsContainer");
      const lyricsWrapper = document.getElementById("lyricsWrapper");
      const lyricsLoading = document.getElementById("lyricsLoading");
      const lyricsNone = document.getElementById("lyricsNone");
      const lyricsContent = document.getElementById("lyricsContent");

      let currentLyrics = [];
      let activeLyricIndex = -1;
      let lyricsInterval = null;

      /**
       * Fetch lyrics from LRCLIB API
       */
      async function fetchLyrics(trackName, artistName) {
        setLyricsState("loading");

        try {
          const params = new URLSearchParams({
            track_name: trackName,
            artist_name: artistName,
          });

          const response = await fetch(
            `https://lrclib.net/api/search?${params.toString()}`
          );

          if (!response.ok) {
            throw new Error("LRCLIB API error");
          }

          const data = await response.json();

          if (!data || data.length === 0) {
            setLyricsState("none");
            return null;
          }

          // Find best match with synced lyrics
          const match = data.find((item) => item.syncedLyrics);

          if (!match || !match.syncedLyrics) {
            setLyricsState("none");
            return null;
          }

          return match.syncedLyrics;
        } catch (error) {
          console.error("Lyrics fetch error:", error);
          setLyricsState("none");
          return null;
        }
      }

      /**
       * Parse LRC format to structured array
       * Format: [mm:ss.xx] text
       */
      function parseLRC(lrcString) {
        const lines = lrcString.split("\n");
        const lyrics = [];

        const timeRegex = /\[(\d{2}):(\d{2})(?:[.:](\d{2,3}))?\]/g;

        for (const line of lines) {
          const matches = [...line.matchAll(timeRegex)];
          if (matches.length === 0) continue;

          // Extract text after all timestamps
          const text = line.replace(timeRegex, "").trim();
          if (!text) continue;

          for (const match of matches) {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const ms = match[3]
              ? parseInt(match[3].padEnd(3, "0").slice(0, 3), 10)
              : 0;

            const time = minutes * 60 + seconds + ms / 1000;

            lyrics.push({ time, text });
          }
        }

        // Sort by time
        lyrics.sort((a, b) => a.time - b.time);

        return lyrics;
      }

      /**
       * Set lyrics display state
       */
      function setLyricsState(state) {
        lyricsLoading.classList.toggle("active", state === "loading");
        lyricsNone.classList.toggle("active", state === "none");
        lyricsContent.style.display = state === "lyrics" ? "flex" : "none";

        if (state !== "lyrics") {
          lyricsWrapper.style.transform = "translateY(-50%)";
        }
      }

      /**
       * Render lyrics lines in the DOM
       */
      function renderLyrics(lyrics) {
        lyricsContent.innerHTML = "";
        currentLyrics = lyrics;
        activeLyricIndex = -1;

        lyrics.forEach((lyric, index) => {
          const line = document.createElement("div");
          line.className = "lyrics-line";
          line.textContent = lyric.text;
          line.dataset.index = index;
          lyricsContent.appendChild(line);
        });

        setLyricsState("lyrics");
      }

      /**
       * Update active lyric based on current time
       */
      function updateActiveLyric(currentTime) {
        if (currentLyrics.length === 0) return;

        // Find the current lyric index
        let newIndex = -1;
        for (let i = currentLyrics.length - 1; i >= 0; i--) {
          if (currentTime >= currentLyrics[i].time) {
            newIndex = i;
            break;
          }
        }

        if (newIndex === activeLyricIndex) return;

        activeLyricIndex = newIndex;

        // Update line classes
        const lines = lyricsContent.querySelectorAll(".lyrics-line");
        lines.forEach((line, index) => {
          line.classList.remove("active", "past", "near");

          if (index === activeLyricIndex) {
            line.classList.add("active");
          } else if (index < activeLyricIndex) {
            line.classList.add("past");
          } else if (index <= activeLyricIndex + 2) {
            line.classList.add("near");
          }
        });

        // Scroll to active line
        scrollToActiveLine();
      }

      /**
       * Smooth scroll to center active lyric line
       */
      function scrollToActiveLine() {
        if (activeLyricIndex < 0) return;

        const activeLine = lyricsContent.querySelector(".lyrics-line.active");
        if (!activeLine) return;

        const containerHeight = lyricsContainer.offsetHeight;
        const lineOffset = activeLine.offsetTop;
        const lineHeight = activeLine.offsetHeight;

        // Calculate offset to center the active line
        // Center of the line should be at center of container
        const scrollOffset = lineOffset + lineHeight / 2;

        lyricsWrapper.style.transform = `translateY(${-scrollOffset}px)`;
      }

      /**
       * Start lyrics synchronization
       */
      function startLyricsSync() {
        if (lyricsInterval) clearInterval(lyricsInterval);

        lyricsInterval = setInterval(() => {
          const elapsed = (Date.now() - musicStartTime) / 1000;
          // Apply optional lyrics delay here so the active line selection
          // can be shifted forward/backward to compensate for latency.
          const currentTime =
            musicInitialPosition + elapsed + (config.lyricsDelaySeconds || 0);
          updateActiveLyric(currentTime);
        }, 100);
      }

      /**
       * Set lyrics delay in seconds at runtime. Positive values delay lyrics
       * (show later), negative values advance them (show earlier).
       */
      function setLyricsDelay(seconds) {
        if (typeof seconds !== "number" || isNaN(seconds)) return;
        config.lyricsDelaySeconds = seconds;

        // If sync is running, restart to immediately apply the new delay
        if (lyricsInterval) {
          clearInterval(lyricsInterval);
          lyricsInterval = null;
          startLyricsSync();
        }
      }

      /**
       * Stop lyrics synchronization
       */
      function stopLyricsSync() {
        if (lyricsInterval) {
          clearInterval(lyricsInterval);
          lyricsInterval = null;
        }
        currentLyrics = [];
        activeLyricIndex = -1;
        lyricsContent.innerHTML = "";
        setLyricsState("none");
      }

      // ========== MUSIC ==========
      let musicTimeout;
      let progressInterval;
      let musicStartTime;
      let musicInitialPosition = 0;
      let musicDuration = 0;

      socket.on("musicData", (data) => {
        // Clear previous timers
        if (musicTimeout) clearTimeout(musicTimeout);
        if (progressInterval) clearInterval(progressInterval);
        stopLyricsSync();

        // Store timing FIRST (needed for lyrics sync)
        musicInitialPosition = data.position || 0;
        musicDuration = data.duration || 0;
        musicStartTime = Date.now();

        // Afficher la durée totale formatée
        if (musicDurationEl)
          musicDurationEl.textContent = formatTime(musicDuration);

        // Update music info
        trackEl.textContent = data.title;
        artistEl.textContent = data.artist;
        coverEl.src = data.cover || "";

        // Fetch and display lyrics (async, timing vars already set)
        fetchLyrics(data.title, data.artist).then((syncedLyrics) => {
          if (syncedLyrics) {
            const lyrics = parseLRC(syncedLyrics);
            if (lyrics.length > 0) {
              renderLyrics(lyrics);
              startLyricsSync();
            } else {
              setLyricsState("none");
            }
          }
        });

        // Extract dominant color from cover
        if (data.cover) {
          const img = new Image();
          img.crossOrigin = "Anonymous";
          img.src = data.cover;

          img.onload = () => {
            try {
              const colorThief = new ColorThief();
              const [r, g, b] = colorThief.getColor(img);
              const luminance = 0.299 * r + 0.587 * g + 0.114 * b;

              // Apply dynamic gradient
              musicCard.style.background = `
                linear-gradient(135deg, 
                  rgba(${r}, ${g}, ${b}, 0.3) 0%, 
                  rgba(${r * 0.7}, ${g * 0.7}, ${b * 0.7}, 0.2) 100%
                )
              `;
            } catch (e) {
              console.error("Color extraction failed:", e);
            }
          };
        }

        // Show music card with animation
        musicCard.classList.remove("hidden");
        updateForecastLayout();

        // Smooth progress animation
        progressInterval = setInterval(() => {
          const elapsed = (Date.now() - musicStartTime) / 1000;
          const currentPosition = musicInitialPosition + elapsed;
          let progress = 0;
          if (musicDuration > 0) {
            progress = Math.min((currentPosition / musicDuration) * 100, 100);
          }
          progressBar.style.width = `${progress}%`;

          if (musicDuration > 0 && currentPosition >= musicDuration) {
            clearInterval(progressInterval);
            hideMusicCard();
          }
        }, 100); // Update every 100ms for smooth animation

        // Auto-hide when song ends
        const remaining = musicDuration - musicInitialPosition;
        if (remaining > 0) {
          musicTimeout = setTimeout(() => {
            hideMusicCard();
          }, remaining * 1000);
        }
      });

      function hideMusicCard() {
        musicCard.classList.add("hidden");
        if (progressInterval) clearInterval(progressInterval);
        progressBar.style.width = "0%";
        if (musicDurationEl) musicDurationEl.textContent = "0:00";
        stopLyricsSync();
        updateForecastLayout();
      }

      function formatTime(seconds) {
        if (!seconds || isNaN(seconds) || seconds <= 0) return "0:00";
        const s = Math.floor(seconds % 60);
        const m = Math.floor(seconds / 60);
        return `${m}:${s.toString().padStart(2, "0")}`;
      }

      // ========== START ==========
      init();
    </script>
  </body>
</html>
